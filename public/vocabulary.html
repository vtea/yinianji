<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>è‹±è¯­å•è¯æœ¬</title>
  <!-- Tailwind CSS -->
  <link href="/output.css?v=4.0.0" rel="stylesheet">
  <style>
    /* åªä¿ç•™ Tailwind æ— æ³•å®ç°çš„ç‰¹æ®Šæ ·å¼ */
    :root {
      --primary-color: #58cc02;
      --primary-hover: #46a302;
      --secondary-color: #1cb0f6;
      --accent-color: #ffc800;
      --text-color: #4b4b4b;
      --border-color: #e5e5e5;
    }

    body {
      font-family: "din-round", "Microsoft YaHei", sans-serif;
    }

    /* äº¤äº’åŠ¨ç”» */
    .back-btn {
      transition: all 0.1s;
    }

    .back-btn:hover {
      background-color: #f7f7f7;
    }

    .back-btn:active {
      transform: translateY(4px);
      box-shadow: 0 0 0;
    }

    .word-card {
      transition: all 0.2s;
    }

    .word-card:hover {
      background-color: #f7f7f7;
      transform: translateY(-2px);
    }

    .word-card:active {
      transform: translateY(2px);
      box-shadow: 0 0px 0 var(--border-color);
    }

    /* éŸ³æ ‡æ˜¾ç¤ºäº¤äº’ */
    .word-phonetic {
      display: none;
      transition: all 0.3s;
    }
    
    .word-phonetic.show {
      display: inline-block !important;
    }

    /* åˆ é™¤æŒ‰é’®åŠ¨ç”» */
    .remove-btn {
      transition: all 0.1s;
    }

    .remove-btn:active {
      transform: translateY(2px);
      box-shadow: 0 0 0;
    }
  </style>
</head>
<body>
<div class="container">
  <div class="header">
    <div class="section-title">æˆ‘çš„å•è¯æœ¬</div>
    <button class="back-btn" onclick="goBack()">è¿”å›å­¦ä¹ </button>
  </div>
  <div id="contentArea">
    <div class="word-list" id="wordList"></div>
  </div>
</div>

<script>
// å®‰å…¨è·å–ç”¨æˆ·ä¿¡æ¯
let currentUser = null;
try {
  const userStr = localStorage.getItem("currentUser");
  if (userStr) {
    currentUser = JSON.parse(userStr);
  }
} catch (err) {
  console.error("è§£æç”¨æˆ·ä¿¡æ¯å¤±è´¥ï¼š", err);
  currentUser = null;
}

// ä¿å­˜å·²æ˜¾ç¤ºçš„éŸ³æ ‡çŠ¶æ€
let shownPhoneticSet = new Set();

function goBack() {
  window.location.href = "english.html";
}

function speakWord(english) {
  if (!english) return;
  
  // å…ˆæ’­æ”¾è¯­éŸ³
  if (window.parent && window.parent.speak) {
    window.parent.speak(english, 'english');
  } else {
    const saved = localStorage.getItem("voiceSettings");
    const voiceSettings = saved ? JSON.parse(saved) : { rate: 0.8 };
    const u = new SpeechSynthesisUtterance(english);
    u.lang = "en-US";
    u.rate = voiceSettings.rate;
    speechSynthesis.cancel();
    setTimeout(() => {
      speechSynthesis.speak(u);
    }, 50);
  }
  
  // æ›´æ–°æ’­æ”¾æ¬¡æ•°
  if (currentUser) {
    fetch("/api/english-new-words/speak", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ 
        user_id: currentUser.user_id, 
        word: english 
      })
    }).then(res => {
      if (res.ok) {
        // æ›´æ–°UIæ˜¾ç¤ºçš„æ’­æ”¾æ¬¡æ•°
        const cards = document.querySelectorAll(".word-card");
        cards.forEach(card => {
          const englishEl = card.querySelector(".word-english");
          if (englishEl && englishEl.textContent === english) {
            const countEl = card.querySelector(".play-count");
            if (countEl) {
              const countMatch = countEl.textContent.match(/\d+/);
              const count = countMatch ? parseInt(countMatch[0]) : 0;
              countEl.textContent = `ğŸ”Š ${count + 1}`;
            }
          }
        });
      }
    }).catch(err => console.error("æ›´æ–°æ’­æ”¾æ¬¡æ•°å¤±è´¥ï¼š", err));
  }
}

async function removeWord(event, wordObj) {
  event.stopPropagation();
  if (!currentUser) return;
  
  if (!confirm(`ç¡®å®šè¦ä»å•è¯æœ¬ä¸­åˆ é™¤ "${wordObj.word}" å—ï¼Ÿ`)) return;

  if (currentUser) {
    const deletedKey = `deletedEnglish_${currentUser.user_id}`;
    const raw = localStorage.getItem(deletedKey);
    const map = raw ? JSON.parse(raw) : {};
    map[wordObj.word] = {
      created_at: wordObj.created_at,
      play_count: wordObj.play_count || 0
    };
    localStorage.setItem(deletedKey, JSON.stringify(map));
  }

  try {
    const res = await fetch("/api/english-new-words", {
      method: "DELETE",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ 
        user_id: currentUser.user_id, 
        word: wordObj.word 
      })
    });
    
    if (res.ok) {
      loadNewWords();
    }
  } catch (err) {
    console.error("åˆ é™¤å¤±è´¥ï¼š", err);
  }
}

function createWordCard(wordObj) {
  const date = new Date(wordObj.created_at).toLocaleDateString();
  const playCount = wordObj.play_count || 0;
  const card = document.createElement("div");
  card.className = "word-card";
  card.innerHTML = `
    <button class="remove-btn" onclick="removeWord(event, ${JSON.stringify(wordObj).replace(/"/g, '&quot;')})">âœ•</button>
    <div class="word-content-wrapper">
      <div class="word-english">${wordObj.word}</div>
      <div class="word-phonetic" data-phonetic="${wordObj.phonetic || ''}">${wordObj.phonetic || ''}</div>
    </div>
    <div class="word-chinese">${wordObj.chinese || ''}</div>
    <div class="word-info">
      <span>ğŸ“… ${date}</span>
      <span class="play-count">ğŸ”Š ${playCount}</span>
    </div>
  `;
  
  const phoneticEl = card.querySelector(".word-phonetic");
  const removeBtn = card.querySelector(".remove-btn");
  
  // æ¢å¤ä¹‹å‰æ˜¾ç¤ºçš„éŸ³æ ‡çŠ¶æ€
  if (phoneticEl && shownPhoneticSet.has(wordObj.word)) {
    phoneticEl.classList.add('show');
    phoneticEl.style.display = 'inline-block';
    phoneticEl.style.backgroundColor = '#e3f2fd';
    phoneticEl.style.color = '#1976d2';
  }
  
  // ç‚¹å‡»å¡ç‰‡æœ—è¯»å¹¶æ˜¾ç¤ºéŸ³æ ‡
  card.addEventListener('click', function(e) {
    // æ£€æŸ¥ç‚¹å‡»çš„æ˜¯å¦æ˜¯åˆ é™¤æŒ‰é’®
    const target = e.target;
    const isExcluded = target.classList.contains('remove-btn') || 
                      target.closest('.remove-btn');
    
    if (!isExcluded) {
      // æ˜¾ç¤ºéŸ³æ ‡ï¼ˆä¸€ç›´æ˜¾ç¤ºï¼Œä¸è‡ªåŠ¨éšè—ï¼‰
      const currentPhoneticEl = card.querySelector(".word-phonetic");
      
      if (currentPhoneticEl) {
        // ç¡®ä¿éŸ³æ ‡æœ‰å†…å®¹
        const phoneticText = currentPhoneticEl.getAttribute('data-phonetic') || wordObj.phonetic || '';
        if (phoneticText) {
          currentPhoneticEl.textContent = phoneticText;
        }
        
        // ç›´æ¥æ˜¾ç¤º - ä½¿ç”¨displayæ§åˆ¶
        currentPhoneticEl.classList.add('show');
        currentPhoneticEl.style.display = 'inline-block';
        currentPhoneticEl.style.backgroundColor = '#e3f2fd';
        currentPhoneticEl.style.color = '#1976d2';
        
        // ä¿å­˜åˆ°å·²æ˜¾ç¤ºé›†åˆ
        shownPhoneticSet.add(wordObj.word);
      }
      
      // æœ—è¯»
      speakWord(wordObj.word);
    }
  });
  
  return card;
}

async function loadNewWords() {
  if (!currentUser) {
    document.getElementById("contentArea").innerHTML = '<div class="empty-message">è¯·å…ˆç™»å½•</div>';
    return;
  }
  
  const contentArea = document.getElementById("contentArea");
  const wordList = document.getElementById("wordList");
  
  if (!contentArea || !wordList) return;
  
  try {
    const res = await fetch(`/api/english-new-words/${currentUser.user_id}`);
    
    if (!res.ok) {
      throw new Error(`HTTP error! status: ${res.status}`);
    }
    
    const words = await res.json();
    
    if (!Array.isArray(words)) {
      throw new Error("è¿”å›çš„æ•°æ®æ ¼å¼ä¸æ­£ç¡®");
    }
    
    wordList.innerHTML = "";
    
    if (words.length === 0) {
      contentArea.innerHTML = '<div class="empty-message">å•è¯æœ¬è¿˜æ˜¯ç©ºçš„ï¼Œå»å­¦ä¹ æ–°å•è¯å§ï¼</div>';
      return;
    }
    
    // ç¡®ä¿contentAreaåŒ…å«wordList
    if (!contentArea.contains(wordList)) {
      contentArea.innerHTML = '<div class="word-list" id="wordList"></div>';
    }
    
    words.forEach(word => {
      const list = document.getElementById("wordList");
      if (list) {
        list.appendChild(createWordCard(word));
      }
    });
  } catch (err) {
    console.error("åŠ è½½å•è¯æœ¬å¤±è´¥ï¼š", err);
    contentArea.innerHTML = '<div class="empty-message">åŠ è½½å•è¯æœ¬å¤±è´¥ï¼Œè¯·åˆ·æ–°é¡µé¢é‡è¯•</div>';
  }
}

if (currentUser) {
  loadNewWords();
} else {
  document.getElementById("contentArea").innerHTML = '<div class="empty-message">è¯·å…ˆç™»å½•</div>';
}
</script>
</body>
</html>
